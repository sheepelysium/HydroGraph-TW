app:
  description: å°ç£æ°´æ–‡çŸ¥è­˜åœ–è­œ - GraphRAG + TimeseriesRAG æ··åˆæŸ¥è©¢ç³»çµ±
  icon: ğŸŒŠ
  icon_background: '#0EA5E9'
  mode: workflow
  name: HydroGraph-TW GraphRAG

kind: app
version: 0.1.2

workflow:
  environment_variables: []

  features:
    file_upload:
      image:
        enabled: false
    opening_statement: ä½ å¥½!æˆ‘æ˜¯å°ç£æ°´æ–‡ç›£æ¸¬åŠ©æ‰‹,å¯ä»¥å¹«ä½ æŸ¥è©¢æ²³å·å®‰å…¨ç‹€æ³ã€‚\n\nä½ å¯ä»¥å•æˆ‘:\n- æ·¡æ°´æ²³ç¾åœ¨å®‰å…¨å—?\n- å“ªäº›æ²³å·æœ‰è­¦æˆ’?\n- ç¢§æ½­æ¸¬ç«™ç›®å‰ç‹€æ³?\n- æ·¡æ°´æ²³ä¸Šæ¸¸é›¨é‡å¦‚ä½•?
    retriever_resource:
      enabled: false
    sensitive_word_avoidance:
      enabled: false
    speech_to_text:
      enabled: false
    suggested_questions:
      - æ·¡æ°´æ²³ç¾åœ¨å®‰å…¨å—?
      - å“ªäº›æ²³å·æœ‰è­¦æˆ’?
      - ç¢§æ½­æ¸¬ç«™ç›®å‰ç‹€æ³?
    suggested_questions_after_answer:
      enabled: true
    text_to_speech:
      enabled: false
      language: ''
      voice: ''

  graph:
    edges:
      # START -> æ„åœ–è§£æ
      - id: start-to-parse-intent
        source: start
        target: parse_intent

      # æ„åœ–è§£æ -> æ¢ä»¶è·¯ç”±
      - id: parse-intent-to-route
        source: parse_intent
        target: route_by_intent

      # æ¢ä»¶è·¯ç”± -> Neo4jæŸ¥è©¢ (safety_check)
      - id: route-to-graph-query
        source: route_by_intent
        sourceHandle: safety_check
        target: graph_query_neo4j

      # æ¢ä»¶è·¯ç”± -> å…¨åŸŸæŸ¥è©¢ (find_alerts)
      - id: route-to-find-all
        source: route_by_intent
        sourceHandle: find_alerts
        target: find_all_stations

      # Neo4jæŸ¥è©¢ -> TimeseriesRAG
      - id: graph-to-timeseries
        source: graph_query_neo4j
        target: timeseries_query

      # å…¨åŸŸæŸ¥è©¢ -> TimeseriesRAG
      - id: find-all-to-timeseries
        source: find_all_stations
        target: timeseries_query

      # TimeseriesRAG -> é¢¨éšªåˆ†æ
      - id: timeseries-to-risk
        source: timeseries_query
        target: risk_analysis

      # é¢¨éšªåˆ†æ -> ç”Ÿæˆå›ç­”
      - id: risk-to-answer
        source: risk_analysis
        target: generate_answer

      # ç”Ÿæˆå›ç­” -> END
      - id: answer-to-end
        source: generate_answer
        target: end

    nodes:
      # ============================================================
      # ç¯€é» 1: START
      # ============================================================
      - data:
          desc: ä½¿ç”¨è€…è¼¸å…¥å•é¡Œ
          selected: false
          title: START
          type: start
          variables:
            - label: ä½¿ç”¨è€…å•é¡Œ
              max_length: 1000
              required: true
              type: text-input
              variable: query
        id: start
        position:
          x: 100
          y: 300
        type: start

      # ============================================================
      # ç¯€é» 2: æ„åœ–è§£æ (LLM)
      # ============================================================
      - data:
          context:
            enabled: false
          desc: ä½¿ç”¨ LLM è§£æä½¿ç”¨è€…æ„åœ–,æå–æ²³å·åç¨±å’ŒæŸ¥è©¢é¡å‹
          memory:
            query_prompt_template: ''
            role_prefix:
              assistant: ''
              user: ''
            window:
              enabled: false
              size: 50
          model:
            completion_params:
              temperature: 0.1
            mode: chat
            name: gpt-4o-mini
            provider: openai
          prompt_template:
            - role: system
              text: |-
                ä½ æ˜¯å°ç£æ°´æ–‡ç›£æ¸¬ç³»çµ±çš„æ„åœ–è§£æå™¨ã€‚

                è«‹åˆ†æä½¿ç”¨è€…å•é¡Œ,æå–ä»¥ä¸‹è³‡è¨Š:
                1. intent: æŸ¥è©¢æ„åœ–
                   - safety_check: æŸ¥è©¢ç‰¹å®šæ²³å·å®‰å…¨ç‹€æ³ (ä¾‹å¦‚: "æ·¡æ°´æ²³å®‰å…¨å—?")
                   - find_alerts: æŸ¥è©¢æ‰€æœ‰è­¦æˆ’æ¸¬ç«™ (ä¾‹å¦‚: "å“ªäº›æ²³å·æœ‰è­¦æˆ’?")
                   - station_query: æŸ¥è©¢ç‰¹å®šæ¸¬ç«™ (ä¾‹å¦‚: "ç¢§æ½­æ¸¬ç«™ç‹€æ³?")

                2. river_name: æ²³å·åç¨± (å¦‚æœæœ‰çš„è©±)
                3. station_name: æ¸¬ç«™åç¨± (å¦‚æœæœ‰çš„è©±)

                è«‹ä»¥ JSON æ ¼å¼å›ç­”,æ ¼å¼å¦‚ä¸‹:
                {
                  "intent": "safety_check",
                  "river_name": "æ·¡æ°´æ²³",
                  "station_name": null
                }

                å¸¸è¦‹æ²³å·: æ·¡æ°´æ²³ã€å¤§ç”²æºªã€æ¿æ°´æºªã€é«˜å±æºªã€æ›¾æ–‡æºªã€è˜­é™½æºªã€ç§€å§‘å·’æºªã€å‘å—æºª
            - role: user
              text: '{{#start.query#}}'
          selected: false
          title: æ„åœ–è§£æ
          vision:
            enabled: false
        id: parse_intent
        position:
          x: 300
          y: 300
        type: llm

      # ============================================================
      # ç¯€é» 3: æ¢ä»¶è·¯ç”± (IF/ELSE)
      # ============================================================
      - data:
          cases:
            - case_id: safety_check
              conditions:
                - comparison_operator: contains
                  id: condition_1
                  value: safety_check
                  variable_selector:
                    - parse_intent
                    - text
              logical_operator: and
            - case_id: find_alerts
              conditions:
                - comparison_operator: contains
                  id: condition_2
                  value: find_alerts
                  variable_selector:
                    - parse_intent
                    - text
              logical_operator: and
          desc: æ ¹æ“šæ„åœ–æ±ºå®šæŸ¥è©¢è·¯å¾‘
          selected: false
          title: æ¢ä»¶è·¯ç”±
        id: route_by_intent
        position:
          x: 500
          y: 300
        type: if-else

      # ============================================================
      # ç¯€é» 4: Neo4j GraphRAG æŸ¥è©¢ (Code)
      # ============================================================
      - data:
          code: |-
            import json
            from neo4j import GraphDatabase

            def main(intent_json: str) -> dict:
                """å¾ Neo4j æŸ¥è©¢æ¸¬ç«™ - GraphRAG æ ¸å¿ƒ"""

                # è§£ææ„åœ–
                try:
                    intent_data = json.loads(intent_json)
                except:
                    # å¦‚æœä¸æ˜¯JSON,å˜—è©¦æå–æ²³å·åç¨±
                    import re
                    match = re.search(r'"river_name":\s*"([^"]+)"', intent_json)
                    river_name = match.group(1) if match else "æ·¡æ°´æ²³"
                    intent_data = {"river_name": river_name}

                river_name = intent_data.get("river_name", "æ·¡æ°´æ²³")

                # é€£æ¥ Neo4j
                # TODO: å°‡é€£ç·šè³‡è¨Šæ”¹ç‚ºç’°å¢ƒè®Šæ•¸
                driver = GraphDatabase.driver(
                    "bolt://localhost:7687",
                    auth=("neo4j", "12345678")
                )

                # Cypher æŸ¥è©¢ - æ‰¾å‡ºæ•´å€‹æµåŸŸçš„æ¸¬ç«™
                cypher = f"""
                MATCH (r:River {{name: '{river_name}'}})-[:BELONGS_TO]->(ws:WaterSystem)
                MATCH (all_rivers:River)-[:BELONGS_TO]->(ws)
                MATCH (s:Station)-[:MONITORS]->(all_rivers)
                RETURN DISTINCT s.code AS code,
                       s.name AS name,
                       s.type AS type,
                       all_rivers.name AS river,
                       labels(s) AS labels
                LIMIT 20
                """

                stations = []
                try:
                    with driver.session() as session:
                        result = session.run(cypher)
                        for record in result:
                            stations.append({
                                "code": str(record["code"]).strip(),
                                "name": str(record["name"]),
                                "type": str(record["type"]),
                                "river": str(record["river"]),
                                "labels": record["labels"]
                            })
                finally:
                    driver.close()

                return {
                    "stations": stations,
                    "count": len(stations),
                    "river_name": river_name
                }
          code_language: python3
          desc: å¾ Neo4j çŸ¥è­˜åœ–è­œæŸ¥è©¢æ²³å·æµåŸŸçš„æ‰€æœ‰æ¸¬ç«™
          outputs:
            stations:
              type: array[object]
            count:
              type: number
            river_name:
              type: string
          selected: false
          title: Neo4j GraphRAG æŸ¥è©¢
          variables:
            - value_selector:
                - parse_intent
                - text
              variable: intent_json
        id: graph_query_neo4j
        position:
          x: 700
          y: 200
        type: code

      # ============================================================
      # ç¯€é» 5: æŸ¥è©¢æ‰€æœ‰æ¸¬ç«™ (Code) - ç”¨æ–¼ find_alerts
      # ============================================================
      - data:
          code: |-
            from neo4j import GraphDatabase

            def main() -> dict:
                """æŸ¥è©¢æ‰€æœ‰æ¸¬ç«™"""

                driver = GraphDatabase.driver(
                    "bolt://localhost:7687",
                    auth=("neo4j", "12345678")
                )

                cypher = """
                MATCH (s:Station)-[:MONITORS]->(r:River)
                RETURN DISTINCT s.code AS code,
                       s.name AS name,
                       s.type AS type,
                       r.name AS river,
                       labels(s) AS labels
                ORDER BY r.name, s.name
                LIMIT 50
                """

                stations = []
                try:
                    with driver.session() as session:
                        result = session.run(cypher)
                        for record in result:
                            stations.append({
                                "code": str(record["code"]).strip(),
                                "name": str(record["name"]),
                                "type": str(record["type"]),
                                "river": str(record["river"]),
                                "labels": record["labels"]
                            })
                finally:
                    driver.close()

                return {
                    "stations": stations,
                    "count": len(stations),
                    "river_name": "å…¨å°ç£"
                }
          code_language: python3
          desc: æŸ¥è©¢æ‰€æœ‰æ¸¬ç«™ (ç”¨æ–¼å…¨åŸŸè­¦æˆ’æŸ¥è©¢)
          outputs:
            stations:
              type: array[object]
            count:
              type: number
            river_name:
              type: string
          selected: false
          title: æŸ¥è©¢æ‰€æœ‰æ¸¬ç«™
        id: find_all_stations
        position:
          x: 700
          y: 400
        type: code

      # ============================================================
      # ç¯€é» 6: TimeseriesRAG ä¸¦è¡ŒæŸ¥è©¢ (Code)
      # ============================================================
      - data:
          code: |-
            import requests
            from concurrent.futures import ThreadPoolExecutor, as_completed
            import json

            def main(stations_json: str) -> dict:
                """ä¸¦è¡ŒæŸ¥è©¢ WRA API å³æ™‚è³‡æ–™ - TimeseriesRAG"""

                # è§£ææ¸¬ç«™åˆ—è¡¨
                try:
                    data = json.loads(stations_json)
                    stations = data.get("stations", [])
                except:
                    return {
                        "water_levels": [],
                        "rainfalls": [],
                        "error": "ç„¡æ³•è§£ææ¸¬ç«™è³‡æ–™"
                    }

                if not stations:
                    return {
                        "water_levels": [],
                        "rainfalls": [],
                        "error": "æ²’æœ‰æ‰¾åˆ°æ¸¬ç«™"
                    }

                def query_water_level(station):
                    """æŸ¥è©¢æ°´ä½ç«™"""
                    try:
                        url = f"https://fhy.wra.gov.tw/WraApi/v1/Station/Water/{station['code']}"
                        response = requests.get(url, timeout=5)
                        data = response.json()

                        return {
                            "success": True,
                            "type": "water",
                            "code": station["code"],
                            "name": station["name"],
                            "river": station["river"],
                            "current_level": float(data.get("WaterLevel", 0) or 0),
                            "alert_1": float(data.get("AlertLevel1", 999) or 999),
                            "alert_2": float(data.get("AlertLevel2", 999) or 999),
                        }
                    except Exception as e:
                        return {"success": False, "error": str(e)}

                def query_rainfall(station):
                    """æŸ¥è©¢é›¨é‡ç«™"""
                    try:
                        url = f"https://fhy.wra.gov.tw/WraApi/v1/Rain/Station/{station['code']}"
                        response = requests.get(url, timeout=5)
                        data = response.json()

                        return {
                            "success": True,
                            "type": "rain",
                            "code": station["code"],
                            "name": station["name"],
                            "river": station["river"],
                            "rainfall_1h": float(data.get("Rainfall_1hr", 0) or 0),
                        }
                    except Exception as e:
                        return {"success": False, "error": str(e)}

                # ä¸¦è¡ŒæŸ¥è©¢
                water_levels = []
                rainfalls = []

                with ThreadPoolExecutor(max_workers=15) as executor:
                    futures = {}

                    for station in stations[:20]:  # é™åˆ¶æœ€å¤š20å€‹æ¸¬ç«™
                        if "WaterLevel" in station.get("labels", []):
                            future = executor.submit(query_water_level, station)
                            futures[future] = "water"
                        elif "Rainfall" in station.get("labels", []):
                            future = executor.submit(query_rainfall, station)
                            futures[future] = "rain"

                    for future in as_completed(futures):
                        result = future.result()
                        if result.get("success"):
                            if result["type"] == "water":
                                water_levels.append(result)
                            else:
                                rainfalls.append(result)

                return {
                    "water_levels": water_levels,
                    "rainfalls": rainfalls,
                    "total_queried": len(water_levels) + len(rainfalls)
                }
          code_language: python3
          desc: ä¸¦è¡ŒæŸ¥è©¢ WRA API å–å¾—å³æ™‚ç›£æ¸¬è³‡æ–™
          outputs:
            water_levels:
              type: array[object]
            rainfalls:
              type: array[object]
            total_queried:
              type: number
          selected: false
          title: TimeseriesRAG æŸ¥è©¢
          variables:
            - value_selector:
                - graph_query_neo4j
                - output
              variable: stations_json
        id: timeseries_query
        position:
          x: 900
          y: 300
        type: code

      # ============================================================
      # ç¯€é» 7: é¢¨éšªåˆ†æ (Code)
      # ============================================================
      - data:
          code: |-
            import json

            def main(timeseries_json: str) -> dict:
                """åˆ†ææ·¹æ°´é¢¨éšªç­‰ç´š"""

                # è§£æè³‡æ–™
                try:
                    data = json.loads(timeseries_json)
                except:
                    data = {"water_levels": [], "rainfalls": []}

                water_levels = data.get("water_levels", [])
                rainfalls = data.get("rainfalls", [])

                warnings = []

                # æª¢æŸ¥æ°´ä½è­¦æˆ’
                for w in water_levels:
                    if w["current_level"] >= w["alert_2"]:
                        level = "ä¸€ç´šè­¦æˆ’" if w["current_level"] >= w["alert_1"] else "äºŒç´šè­¦æˆ’"
                        warnings.append({
                            "type": "æ°´ä½è­¦æˆ’",
                            "station": w["name"],
                            "river": w["river"],
                            "level": level,
                            "value": f"{w['current_level']:.2f}m",
                            "alert": f"{w['alert_2']:.2f}m"
                        })

                # æª¢æŸ¥é›¨é‡è­¦æˆ’
                for r in rainfalls:
                    if r["rainfall_1h"] >= 50:
                        if r["rainfall_1h"] >= 80:
                            level = "å¤§è±ªé›¨"
                        else:
                            level = "è±ªé›¨"

                        warnings.append({
                            "type": "å¼·é™é›¨",
                            "station": r["name"],
                            "river": r["river"],
                            "level": level,
                            "value": f"{r['rainfall_1h']:.1f}mm/hr",
                            "alert": "50mm/hr"
                        })

                # è¨ˆç®—é¢¨éšªç­‰ç´š
                total = len(water_levels) + len(rainfalls)
                ratio = len(warnings) / total if total > 0 else 0

                if ratio >= 0.3:
                    risk_level = "é«˜é¢¨éšª"
                elif ratio >= 0.1:
                    risk_level = "ä¸­é¢¨éšª"
                elif len(warnings) > 0:
                    risk_level = "ä½é¢¨éšª"
                else:
                    risk_level = "å®‰å…¨"

                return {
                    "risk_level": risk_level,
                    "warnings": warnings,
                    "warning_count": len(warnings),
                    "total_stations": total,
                    "warning_ratio": ratio
                }
          code_language: python3
          desc: åˆ†æé¢¨éšªç­‰ç´šä¸¦æ‰¾å‡ºè­¦æˆ’æ¸¬ç«™
          outputs:
            risk_level:
              type: string
            warnings:
              type: array[object]
            warning_count:
              type: number
            total_stations:
              type: number
            warning_ratio:
              type: number
          selected: false
          title: é¢¨éšªåˆ†æ
          variables:
            - value_selector:
                - timeseries_query
                - output
              variable: timeseries_json
        id: risk_analysis
        position:
          x: 1100
          y: 300
        type: code

      # ============================================================
      # ç¯€é» 8: ç”Ÿæˆæœ€çµ‚å›ç­” (LLM)
      # ============================================================
      - data:
          context:
            enabled: false
          desc: ä½¿ç”¨ LLM ç”Ÿæˆè‡ªç„¶èªè¨€å›ç­”
          memory:
            query_prompt_template: ''
            role_prefix:
              assistant: ''
              user: ''
            window:
              enabled: false
          model:
            completion_params:
              temperature: 0.7
            mode: chat
            name: gpt-4o
            provider: openai
          prompt_template:
            - role: system
              text: |-
                ä½ æ˜¯å°ç£æ°´æ–‡ç›£æ¸¬ç³»çµ±çš„å°ˆæ¥­åŠ©æ‰‹ã€‚

                æ ¹æ“šä»¥ä¸‹ç›£æ¸¬è³‡æ–™å›ç­”ä½¿ç”¨è€…å•é¡Œ:

                æ²³å·/å€åŸŸ: {{#graph_query_neo4j.river_name#}}
                é¢¨éšªç­‰ç´š: {{#risk_analysis.risk_level#}}
                ç›£æ¸¬æ¸¬ç«™ç¸½æ•¸: {{#risk_analysis.total_stations#}} å€‹
                è­¦æˆ’æ¸¬ç«™æ•¸é‡: {{#risk_analysis.warning_count#}} å€‹
                è­¦æˆ’æ¯”ä¾‹: {{#risk_analysis.warning_ratio#}}

                è­¦æˆ’è©³æƒ…:
                {{#risk_analysis.warnings#}}

                è«‹ç”¨è‡ªç„¶ã€æ˜“æ‡‚ã€å°ˆæ¥­çš„èªè¨€å›ç­”,åŒ…å«:
                1. ç›´æ¥å›ç­”å•é¡Œ (å®‰å…¨æˆ–æœ‰é¢¨éšª)
                2. èªªæ˜åŸå›  (å“ªäº›æ¸¬ç«™è­¦æˆ’,æ•¸å€¼å¤šå°‘)
                3. çµ¦å‡ºå…·é«”å»ºè­°

                å›ç­”æ ¼å¼ç¯„ä¾‹:

                ã€é¢¨éšªè©•ä¼°ã€‘
                ç›®å‰ æ·¡æ°´æ²³æµåŸŸ è™•æ–¼ã€Œä½é¢¨éšªã€ç‹€æ…‹ã€‚

                ã€ç›£æ¸¬æ¦‚æ³ã€‘
                ç³»çµ±æ­£åœ¨ç›£æ¸¬ 13 å€‹æ¸¬ç«™,å…¶ä¸­ 1 å€‹æ¸¬ç«™ç™¼å‡ºè­¦æˆ’ã€‚

                ã€è­¦æˆ’è©³æƒ…ã€‘
                1. å…§æ¹–é›¨é‡ç«™ (åŸºéš†æ²³)
                   - é¡å‹: å¼·é™é›¨
                   - ç­‰ç´š: è±ªé›¨
                   - æ•¸å€¼: 79.3mm/hr (è­¦æˆ’å€¼: 50mm/hr)

                ã€å»ºè­°ã€‘
                æ•´é«”å®‰å…¨,ä½†å»ºè­°:
                - æŒçºŒç›£æ§å…§æ¹–ç«™çš„é›¨é‡è®ŠåŒ–
                - è‹¥é›¨å‹¢æŒçºŒå¢å¼·,å¯èƒ½å½±éŸ¿åŸºéš†æ²³æ°´ä½
                - å»ºè­°é—œæ³¨å¤©æ°£é å ±
            - role: user
              text: '{{#start.query#}}'
          selected: false
          title: ç”Ÿæˆå›ç­”
          vision:
            enabled: false
        id: generate_answer
        position:
          x: 1300
          y: 300
        type: llm

      # ============================================================
      # ç¯€é» 9: END
      # ============================================================
      - data:
          outputs:
            - value_selector:
                - generate_answer
                - text
              variable: answer
          selected: false
          title: END
          type: end
        id: end
        position:
          x: 1500
          y: 300
        type: end
